#!/usr/bin/env node

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright (c) 2018, Joyent, Inc.
 */

/*
 * Portolan CLI
 */

'use strict';

var mod_backend = require('../lib/backend');
var mod_bunyan = require('bunyan');
var mod_client = require('../lib/client');
var mod_cmdln = require('cmdln');
var mod_common = require('../lib/common');
var config = require('../etc/config.json');
var mod_types = require('../lib/types');
var mod_util = require('util');
var VError = require('verror').VError;



// --- Globals



var OPTS = {
    cn: {
        names: [ 'cn' ],
        type: 'string',
        help: 'Compute Node UUID'
    },

    help: {
        names: [ 'help', 'h' ],
        type: 'bool',
        help: 'Print help and exit'
    },

    host: {
        names: [ 'host' ],
        type: 'string',
        help: 'Portolan host to connect to'
    },

    ip: {
        names: [ 'ip' ],
        type: 'string',
        help: 'IP address'
    },

    srcip: {
        names: [ 'srcip' ],
        type: 'string',
        help: 'source IP address'
    },

    dstip: {
        names: [ 'dstip' ],
        type: 'string',
        help: 'destination IP address'
    },

    mac: {
        names: [ 'mac' ],
        type: 'string',
        help: 'MAC address'
    },

    port: {
        names: [ 'port' ],
        type: 'positiveInteger',
        help: 'Portolan host port'
    },

    vnet_id: {
        names: [ 'vnet-id', 'vnet_id' ],
        type: 'positiveInteger',
        help: 'Virtual network ID'
    },

    vlan_id: {
        names: [ 'vlan-id', 'vlan_id' ],
        type: 'positiveInteger',
        help: 'Virtual LAN ID'
    },

    count: {
        names: [ 'count' ],
        type: 'positiveInteger',
        help: 'count of bytes to remove'
    },

    id: {
        names: [ 'id', 'uuid' ],
        type: 'arrayOfString',
        help: 'array of log ids to remove'
    },

    net_uuid: {
        names: [ 'net_uuid' ],
        type: 'string',
        help: 'local network uuid'
    },

    r_net_uuid: {
        names: [ 'r_net_uuid' ],
        type: 'string',
        help: 'remote network uuid'
    },

    r_dc_id: {
        names: [ 'r_dc_id' ],
        type: 'positiveInteger',
        help: 'remote datacenter id'
    },

    r_vnet_id: {
        names: [ 'r_vnet_id' ],
        type: 'positiveInteger',
        help: 'remote virtual network ID'
    },

    r_vlan_id: {
        names: [ 'r_vlan_id' ],
        type: 'positiveInteger',
        help: 'remote vlan ID'
    },

    r_send_mac: {
        names: [ 'r_send_mac' ],
        type: 'string',
        help: 'reply mac address'
    },

    subnet: {
        names: [ 'subnet' ],
        type: 'string',
        help: 'local subnet'
    },

    r_subnet: {
        names: [ 'r_subnet' ],
        type: 'string',
        help: 'remote subnet'
    }
};



// --- Internal



/**
 * Output some pretty JSON
 */
function json(obj) {
    console.log(JSON.stringify(obj, null, 2));
}


/**
 * Set the hostname and port for client opts
 */
function setClientOpts(opts, clientOpts) {
    clientOpts.host = opts.host || 'localhost';
    clientOpts.port = opts.port || config.port;
}


/**
 * Rename the options in {Object} opts using {Object} trans (which maps
 * key names in opts to their translated names).  Throw an error if any
 * options are missing.
 */
function translateOpts(opts, trans) {
    var missing = [];
    var translated = {};

    for (var t in trans) {
        if (opts.hasOwnProperty(t)) {
            translated[trans[t]] = opts[t];
        } else {
            missing.push(t);
        }
    }

    if (missing.length !== 0) {
        throw new VError('missing option%s: %s',
            (missing.length === 1 ? '' : 's'),
            missing.join(', '));
    }

    return translated;
}



// --- PortolanCLI object



function PortolanCLI() {
    mod_cmdln.Cmdln.call(this, {
        name: 'portolan',
        description: 'portolan CLI',
        options: [
            OPTS.help
        ]
    });
}

mod_util.inherits(PortolanCLI, mod_cmdln.Cmdln);


/**
 * Run before the subcommand methods - overall initialization
 */
PortolanCLI.prototype.init = function _init(_opts, _args, callback) {
    mod_backend.load(config);

    config.log = mod_bunyan.createLogger({
        name: 'portolan',
        level: process.env.LOG_LEVEL || 'fatal'
    });
    mod_backend.init(config, callback);
};


/**
 * Add an overlay mapping
 */
PortolanCLI.prototype['do_add-overlay'] =
    function _addOverlay(_subcmd, opts, _args, callback) {
    var backendOpts;
    try {
        backendOpts = translateOpts(opts, {
            cn: 'cn_uuid',
            ip: 'ip',
            mac: 'mac',
            vnet_id: 'vnet_id'
        });
        mod_common.validate.opts(backendOpts);
    } catch (optsErr) {
        callback(optsErr);
        return;
    }

    backendOpts.ip = mod_common.IPv6obj(backendOpts.ip);
    backendOpts.mac = mod_common.macToInt(backendOpts.mac);

    mod_backend.addOverlayMapping(backendOpts, callback);
};

PortolanCLI.prototype['do_add-overlay'].options = [
    OPTS.cn,
    OPTS.ip,
    OPTS.mac,
    OPTS.vnet_id
];


/**
 * Add an underlay mapping
 */
PortolanCLI.prototype['do_add-underlay'] =
    function _addUnderlay(_subcmd, opts, _args, callback) {
    var backendOpts;
    try {
        backendOpts = translateOpts(opts, {
            cn: 'cn_uuid',
            ip: 'ip'
        });
        mod_common.validate.opts(backendOpts);
    } catch (optsErr) {
        callback(optsErr);
        return;
    }

    backendOpts.ip = mod_common.IPv6obj(backendOpts.ip);
    backendOpts.port = mod_types.VXLAN_PORT;

    mod_backend.addUnderlayMapping(backendOpts, callback);
};

PortolanCLI.prototype['do_add-underlay'].options = [
    OPTS.cn,
    OPTS.ip
];


/**
 * Ping the portolan server
 */
PortolanCLI.prototype['do_ping'] =
    function _ping(_subcmd, opts, _args, callback) {
    var connOpts = {};
    setClientOpts(opts, connOpts);

    var client = mod_client.connect(connOpts, function _afterVl2Conn(err) {
        if (err) {
            callback(err);
            return;
        }

        client.ping(function (err2, res) {
            if (err2) {
                callback(err2);
                return;
            }

            json(res);
            callback();
        });
    });
};

PortolanCLI.prototype['do_ping'].options = [
    OPTS.host,
    OPTS.port
];


/**
 * Do a L2 lookup
 */
PortolanCLI.prototype['do_vl2-lookup'] =
    function _vl2Req(_subcmd, opts, _args, callback) {
    var connOpts;
    try {
        connOpts = translateOpts(opts, {
            mac: 'mac',
            vnet_id: 'vnet_id'
        });
        mod_common.validate.opts(connOpts);
    } catch (optsErr) {
        callback(optsErr);
        return;
    }

    setClientOpts(opts, connOpts);
    var client = mod_client.connect(connOpts, function _afterVl2Conn(err) {
        if (err) {
            callback(err);
            return;
        }

        client.vl2Req(connOpts, function (err2, res) {
            if (err2) {
                callback(err2);
                return;
            }

            json(res);
            callback();
        });
    });
};

PortolanCLI.prototype['do_vl2-lookup'].options = [
    OPTS.host,
    OPTS.mac,
    OPTS.port,
    OPTS.vnet_id
];


/**
 * Do a L3 lookup
 */
PortolanCLI.prototype['do_vl3-lookup'] =
    function _vl3Req(_subcmd, opts, _args, callback) {
    var connOpts;
    try {
        connOpts = translateOpts(opts, {
            ip: 'ip',
            vnet_id: 'vnet_id'
        });
        mod_common.validate.opts(connOpts);
    } catch (optsErr) {
        callback(optsErr);
        return;
    }

    setClientOpts(opts, connOpts);
    connOpts.ip = mod_common.IPv6obj(opts.ip);

    var client = mod_client.connect(connOpts, function _afterVl3Conn(err) {
        if (err) {
            callback(err);
            return;
        }

        client.vl3Req(connOpts, function (err2, res) {
            if (err2) {
                callback(err2);
                return;
            }

            json(res);
            callback();
        });
    });
};

PortolanCLI.prototype['do_vl3-lookup'].options = [
    OPTS.host,
    OPTS.ip,
    OPTS.port,
    OPTS.vnet_id
];


PortolanCLI.prototype['do_log_req'] =
    function _logReq(_subcmd, opts, _args, callback) {

    try {
        var connOpts = translateOpts(opts, {
            vnet_id: 'vnet_id',
            ip: 'ip',
            count: 'count'
        });
        mod_common.validate.opts(connOpts);
    } catch (optsErr) {
        callback(optsErr);
        return;
    }

    setClientOpts(opts, connOpts);
    connOpts.ip = mod_common.IPv6obj(opts.ip);

    config.log.debug({ msg: connOpts }, 'sending log req');

    var client = mod_client.connect(connOpts, function _afterLogReqConn(err) {
        if (err) {
            callback(err);
            return;
        }

        client.logReq(connOpts, function (err2, res) {
            if (err2) {
                callback(err2);
                return;
            }

            json(res);
            callback();
        });
    });
};

PortolanCLI.prototype['do_log_req'].options = [
    OPTS.host,
    OPTS.ip,
    OPTS.port,
    OPTS.count
];

PortolanCLI.prototype['do_log_rm'] =
    function _logRm(_subcmd, opts, _args, callback) {

    try {
        var connOpts = translateOpts(opts, {
            id: 'ids'
        });
        mod_common.validate.opts(connOpts);
    } catch (optsErr) {
        callback(optsErr);
        return;
    }

    setClientOpts(opts, connOpts);
    connOpts.count = connOpts.ids.length;

    config.log.debug({ msg: connOpts }, 'sending log rm request');
    var client = mod_client.connect(connOpts, function _afterLogRmConn(err) {
        if (err) {
            callback(err);
            return;
        }

        client.logRm(connOpts, function (err2, res) {
            if (err2) {
                callback(err2);
                return;
            }

            json(res);
            callback();
        });
    });
};

PortolanCLI.prototype['do_log_rm'].options = [
    OPTS.id
];

/**
 * Add an vnet route mapping
 */
PortolanCLI.prototype['do_add-vnetroute'] =
    function _addVnetRoute(_subcmd, opts, _args, callback) {

    var backendOpts;
    try {
        backendOpts = translateOpts(opts, {
            vnet_id: 'vnet_id',
            vlan_id: 'vlan_id',
            subnet: 'subnet',
            net_uuid: 'net_uuid',
            r_dc_id: 'r_dc_id',
            r_vnet_id: 'r_vnet_id',
            r_vlan_id: 'r_vlan_id',
            r_subnet: 'r_subnet',
            r_send_mac: 'r_send_mac',
            r_net_uuid: 'r_net_uuid'
        });
        mod_common.validate.opts(backendOpts);
    } catch (optsErr) {
        callback(optsErr);
        return;
    }

    backendOpts.subnet = mod_common.IPv6SubObj(backendOpts.subnet);
    backendOpts.r_subnet = mod_common.IPv6SubObj(backendOpts.r_subnet);
    backendOpts.r_send_mac = mod_common.macToInt(backendOpts.r_send_mac);

    mod_backend.addVnetRouteMapping(backendOpts, callback);
};

PortolanCLI.prototype['do_add-vnetroute'].options = [
    OPTS.host,
    OPTS.port,
    OPTS.vnet_id,
    OPTS.vlan_id,
    OPTS.subnet,
    OPTS.net_uuid,
    OPTS.r_dc_id,
    OPTS.r_vnet_id,
    OPTS.r_vlan_id,
    OPTS.r_subnet,
    OPTS.r_send_mac,
    OPTS.r_net_uuid
];


/**
 * Do a VNET Route lookup
 */
PortolanCLI.prototype['do_vnetroute-lookup'] =
    function _vnetRouteReq(_subcmd, opts, _args, callback) {

    var connOpts;

    try {
        connOpts = translateOpts(opts, {
            vnet_id: 'vnet_id',
            vlan_id: 'vlan_id',
            srcip: 'srcip',
            dstip: 'dstip'
        });
        mod_common.validate.opts(connOpts);
    } catch (optsErr) {
        callback(optsErr);
        return;
    }

    setClientOpts(opts, connOpts);
    connOpts.srcip = mod_common.IPv6obj(connOpts.srcip);
    connOpts.dstip = mod_common.IPv6obj(connOpts.dstip);

    var client = mod_client.connect(connOpts, function _afterVl3Conn(err) {
        if (err) {
            callback(err);
            return;
        }

        client.vnetRouteReq(connOpts, function (err2, res) {
            if (err2) {
                callback(err2);
                return;
            }

            json(res);
            callback();
        });
    });
};

PortolanCLI.prototype['do_vnetroute-lookup'].options = [
    OPTS.host,
    OPTS.port,
    OPTS.vnet_id,
    OPTS.vlan_id,
    OPTS.srcip,
    OPTS.dstip
];

// TODO: add vnetroute-remove


/**
 * List all vnet routes for a given local network uuid
 */
PortolanCLI.prototype['do_vnetroute-list'] =
    function _vnetRouteList(_subcmd, opts, _args, callback) {

    if (config.backend !== 'moray') {
        callback(new VError('vnetroute-list is only supported for the moray '
            + 'backend'));
        return;
    }

    var subopts;

    try {
        subopts = translateOpts(opts, {
            net_uuid: 'net_uuid'
        });
        mod_common.validate.opts(subopts);
    } catch (optsErr) {
        callback(optsErr);
        return;
    }

    subopts.log = config.log;

    mod_backend.listVnetRouteMappings(subopts, function (err, res) {
        if (err) {
            callback(err);
            return;
        }

        json(res);
        callback();
    });
};

PortolanCLI.prototype['do_vnetroute-list'].options = [
    OPTS.net_uuid
];

var cli = new PortolanCLI();
mod_cmdln.main(cli);
